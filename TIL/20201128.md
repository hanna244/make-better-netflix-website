# TIL

20201128 공부한 내용을 기록합니다.

* 쉽게 친해지지 못하고 손이 가지 않았던 넷플릭스 스타일링을 강사님과 같이 실습해보는 첫 날이다. 
  - 잘 못하고 자신이 없으니 2달이라는 시간이 지나는 동안 작업이 제대로 진행되지 않았다. 한마디로 **방치**. 이제는 물러날 곳이 없다. 뒤에는 절벽이고 한 발자국 멀어지면 떨어진다는 생각으로 하자. 나중에 힘든것 보다 지금 힘든게 100배 1000배는 낫다. (하지만 지금 이 순간에도 `js`의 객체 지향 프로그래밍 생각이 나는 구나...)
* 명령어 공부하기
  - 문법 검사를 위해 `.htmlhint`를 실행시키니 설치가 되지 않았다는 오류 메세지가 뜬다. 결국 npm 명령어를 등록하고 `Z shell`, 별칭 등록 , 파일 복사, 이동 등 시작 전에 `VScode` 명령어를 공부했다. 

# 질문하기

1. `.a11yHidden.focusable:focus` 다시 질문하기 

1. 접근성 `:focus`에 `border`가 아닌 `box-shadow`를 적용한 이유

1. `:focus-visible`과 `:focus`의 차이점

1. 파일 불러오고 나서... 고정하는 방법...?

1. `<input>`의 `border`를 지워도 괜찮은가? (접근성)

# 고민하기

1. 스크린 너비 376-1439px 사이에서는 컨테이너의 `margin` 좌/우 공간이 생기지 않음
  - `calc(18 / 960 * 100%)`을 적용했으나 `1440px` 이상 사이즈에서는 컨테이너가 좌측으로 치우침

```css
@media (min-width: 60rem /* 960px/16 */ ) {
  .Container {
    min-width: 90rem;
    margin: 0 auto;
  }
}
```

1. `ourStory`의 `promotion` 
  - 데스트탑 버전에서 `<input>`과 `<button>`을 수평으로 나란히 두기 위해 `promotion__emailContainer`에 `inline-block`을 적용했다
  - 나란히 두니 `<input>`과 `<button>` 사이에 공간이 생겼다. `promotion__emailContainer`때문에 생긴 공간인데 원인이 뭔지 모르겠다. 일단 임의로 음수값을 주어 빈 공백을 없앴다. 
  ```css 
  @media (min-width: 60rem)
  .promotion__emailContainer {
      display: inline-block;
      margin-right: -0.432rem;
  }
  ```
  - 데스크탑 버전에서 `<input>`과 `<button>`의 높이를 어떻게 같도록 할까? 

1. 브라우저의 너비가 넓어지면서 텍스트가 자연스럽게 펼쳐지게 하기 위해서는 내가 스크린의 사이즈 별로 너비를 적용하면 될까?


## 단축키



## Git 명령어

### 쉘?

`Z shell` : 맥 (`iterm`을 사용하기도 함)  
`power shell` : 윈도우   
`gitbash` : 맥과 윈도우를 호환하기 위해서 사용

* `.zshrc`에 별칭 등록
  - `alias` 키워드를 사용해서 별칭을 등록한다. 
  - 예) `clear`명령어를 `cls`라는 단축어를 사용할 수 있도록 등록
  ```sh
  alias cls="clear" 
  ``` 

  - 등록만 하고 끝나는 것이 아니다 설정을 다시 불러오는 명령어를 입력해 줘야 한다.
  ```sh
  source ~/zshrc
  ``` 

  - 설정을 불러온 다음 다시 `Z shell`을 열어서 확인!
  ```sh
  code ~/zshrc
  ``` 
  위의 `code` 명령어도 별칭으로 등록한 것이다.

  <br />


### `glob` 문법

  [글로브 (프로그래밍)](https://ko.wikipedia.org/wiki/%EA%B8%80%EB%A1%9C%EB%B8%8C_(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D))은 컴퓨터에서 특정 명령어로 명령을 내릴 때 사용하는 문법이다. 

### node
`node`여러 버전을 설치 할 수 있는데 그때 각 버전을 관라할 수 있는 도구인 `nvm`을 같이 사용해야 한다. 


### 경험
`node`, `nvm`을 이전에 설치 했지만 명령어에 `-v`을 사용해 찾아봤지만 `Z shell`에서 찾지 못했다. 

* 해결
  설치가 안된 줄 알고 다시 설치 명령어를 입력했을 때 로그에서 설치는 되었지만 `Z shell`에서 찾지 못한다고 얘기해 주었다. `Z shell`에서 해당 도구를 찾을 수 있도록 명령어를 등록해 주어서 해결~! 

### 복사 및 이동 명령어

* 해당 폴더의 파일 목록 보기
```sh
  ls
``` 
* 폴더의 설치된 파일 목록 보기
```sh
  ls -a
``` 
* 파일 복사 하기 
```sh
  cp .htmlhint ~/.htmlhint
``` 
```sh
  cp (복사할 파일) (복사하려는 파일 위치와 저장할 파일 이름) 
``` 
`cp` : `copy` `~/` : 홈 디렉토리 위치 
* 파일 이동 하기

홈 디렉토리에 있는 `.prettierrc` 파일을 현재 위치한 디렉토리로 이동
```sh
  mv ~/.prettierrc .
``` 
`mv` : `move`

현재 디렉토리의 `.txt`로 끝나는 이름의 모든 파일을 `textfiles` 디렉토리로 이동(`mv`)시킨다. 
```sh
  mv *.txt textfiles/
``` 

### htmlhint 

#### 설치

* `i` : `intall`(설치), `-g` : 전역에 설치 (어디에서나 사용 가능하도록 전역에 설치)
```sh
  npm i -g 
```

#### 실행
`htmlhint`으로 `html`문법 검사하기

* 현재 위치에 있는 모든 `.html`파일을 검사해라
```sh
  htmlhint *.html
```

* page 폴더 안에 있는 모든 폴더의 `.html`파일을 검사해라
```sh
  htmlhint src/page/**/*.html
```

## 넷플릭스 실습 

* 공통 스타일 또는 컴포넌트는 처음부터 다 만들려고 하지 말고 작업을 하면서 하나씩 만들기
* `normalize`는 먼저 구글링으로 갖고 오기 주석 지우고 코드 한줄로 만들기 

### 유틸리티 함수
스타일링할 때 필요한 부분의 마크업만 보기 위해서 `hidden`속성 적용하기 위해서 유틸리티 함수를 만든다. 

* 처음에 만들어본 함수   
속성을 적용하는 것에는 성공했지만 어떤 것을 `querySelector`로 찾아와야 원하는 태그를 넣었을 때 적용이 가능한지 잘 모르겠어서 고민을 했다. 
```js
const hiddenContents = document.querySelectorAll('main > *:not(.ourStory), footer')

function hiddenHTMLlements(content) {
  hiddenContents.forEach(function (content) {
    content.setAttribute('hidden', 'hidden')
  })
}

hiddenHTMLlements('main > *:not(.ourStory), footer')

```
* 해답은 `selector`에 있었다!! 몇 번 짜봤던 로직이지만 정작 필요할 때 기억이 안난다. 잊지말고 기억하기~!   
그리고 해당 함수는 따로 파일을 만들어서 `utils`분리

```js
function hiddenHTMLlements(selector) {
  const hiddenContents = document.querySelectorAll(selector)
  hiddenContents.forEach((selector) =>
    selector.setAttribute('hidden', 'hidden')
  )
}
```

### common

#### base
박스 크기 조정, 사용자 정의 초기화, 접근성, 

* 박스 크기 조정   
처음에는 `body`요소에 박스 사이징을 적용하고 `body *`에 상속받는 속성을 입력했다. 공간에 대한 속성을 상속이 되지 않기 때문에 아래 처럼 코드를 입력한 것인데 사실 상속이 필요한 부분은 가상클래스도 있다. 

```css
body {
  box-sizing: border-box;
}

body * {
  box-sizing: inherit;
}
```
아래 코드 처럼 루트 상위 선택자에 박스 사이징을 적용하여 아래 `body`요소가 상속받는 형태로 적용하는 방법으로 적용하자
```css
:root {
  box-sizing: border-box;
}

body,
body *,
body::before,
body::after,
body *::before,
body *::after {
  box-sizing: inherit;
}
```

* 접근성

접근성을 위한 숨김컨텐츠를 만들 경우에 요소가 보이지 안더라도 포커스 되었을 때도 같이 고려해서 속성을 적용해야 한다. 

```css
.a11yHidden.focusable:focus {
  a11yHidden 클래스에 적용한 속서을 모두 상속
}
```

* 마우스로 클릭 했을 때와 키보드로 포커싱 되었을 때 구분해서 스타일링 적용한다. 마우스로 포커싱 되었을 때 테두리에 라인이 생기면 디자인상 예뻐보이지 않기 때문이다. 
* 마우로 클릭 했을 때: `:not()` 선택자를 사용해서 `:focus-visible`가 적용되지 않은 요소는 테두리를 적용하지 않는다.

```css
/* 마우스로 클릭했을 때 */
:focus:not(:focus-visible) {
  box-shadow: none;
}

/* 키보드로 포커싱 되어 화면에 표시 되어야 하는 경우 */
:focus-visible {
  box-shadow: 0 0 0 0.3rem var(--colorFocusable);
}
```

* 참고
  - [[MDN]box-shadow](https://developer.mozilla.org/ko/docs/Web/CSS/box-shadow)
  - [[MDN]:focus-visible](hhttps://developer.mozilla.org/en-US/docs/Web/CSS/:focus-visible)

#### typography
폰트 기본 스타일 적용

* `1.6rem/1.5`는 `font`에 입력하는 `font-size`/`line-height` 속기형이다.
```css
body {
  /* 1.6rem/1.5 size/line-height */
  font: 1.6rem/1.5 SpoqaHanSans, Helvetica, Arial, Sans-serif;
}
```

* `<header>`과 `<p>` 요소에 위/아래 `margin: 0;`을 적용할 때는 `top`에 적용하지 `bottom`에 적용할지 결정한다. 
```css
  h1, h2, h3, h4, h5, h6 p {
    margin-top: 0;
  }
```

### components

#### Container

* 컨테이너 좌/우 마진 값 계산할 때 `%`이용하기! 그리고 `calc()`이용해서 계산하는 방법 잘 기억해 두기 
```css
.Container {
  margin: 0 calc(18 / 375 * 100%);
}
```

* 넷플릿스에 `column`으로 스타일 적용할 수 있는 요소들이 있다. 그때마다 `flex-flow: column wrap;` 따로 적용하지 말고 `column`상태의 클래스를 만들어 적용하면 유지보수가 편하다

```css
.Container--column {
  flex-flow: column wrap;
  justify-content: flex-start;
}
```

* 미디어 쿼리에 고정값을 사용하는 이유는 와이드 스크린이 설정 되었을 때 로고와 로그인 링크가 너무 좌우로 벌어지면 사용자 경험이 좋지 않기 때문에 두 컨텐츠의 간격이 일정 간격이상 멀어지지 안도록 최대 너비 설정

* `margin: 0 auto;`는 빈 공간을 양분한다. 수평으로 가운데 정렬한다. 단, `auto 0`은 적용이 불가능한 이유는 기본값이 0이기 때문에 수직으로 가운데 정렬이 적용되지 않음

```css
@media (min-width: 60rem /* 960px/16 */ ) {
  .Container {
    min-width: 90rem;
    margin: 0 auto;
  }
}

@media (min-width: 90rem /* 1440px/16 */ ) {
  .Container {
    max-width: 120rem;
  }
}
```

#### HomeLink

기존의 `body`에 설정된 `font: 1.6rem/1.5;` 때문에 `h1`에 폰트 사이즈 만큼의 공간이 생겨서 `a`요소가 `h1`의 공간을 벗어나는 이슈가 생겨버림 그래서 `HomeLink`의 폰트 사이즈를 줄였다. 
```css
.HomeLink {
  font-size: 1rem;
}
```

#### Link
버튼의 `padding`값을 구할 때 디자인 시안에 소수점으로 나와 있어서 어떻게 계산을 해야 할지 몰랐다. 먼저 혼자 할 때는 그냥 반올림으로 임의로 계산을 했다.
* 디자인시안이 소수점일 때 계산 방법
  - `padding-top:` 5.5px / 11px = 0.5(em) 
```css
.Link {
  padding: 0.5em 0.6818em 0.7rem;
  font-size: 1.1rem;
}
```

### Our Story

먼저 `ourStory`의 각 `<p>`요소를 스타일링 하기 전에 **일관성**을 위해각 `margin-bottom`은 0으로 하고 **`margin-top`에만 값을 주는 것**으로 정한다. 

#### ourStory__headline

* 고민하기  
디자인 시안에 보면 `영화, TV 프로그램을<br />무제한으로.`의 형태로 줄바뀜이 되어있다. 어떻게 설계해 줘야 할까? (최선의 방법을 찾아서...)
  - `html`마크업에 `<br />` 요소를 추가한다.     
  스크린 리더 사용자에게 좋지 않은 사용자 경험을 제공한다. 스크린 리더가 `<br />` 요소를 읽어 줄 때 "영화, TV 프로그램을" 하고서 한참 위에 "무제한으로."라고 읽어 주기 때문에 사용자가 내용을 파악하기에 어려운 점이 있다. 
  - 각 줄 마다 `<span>`요소로 감싸준다.   
  `<span>영화, TV 프로그램을</span><span>무제한으로.</span>` 이렇게 마크업하고서 `display: block`을 사용해서 스타일링하는 방법이 있다. 하지만 의미가 없는 구조이기 때문에 딱히... 맘에 들지는 않음...
  - `width`값을 주어 원하는 모양이 나오도록 하기    
  모바일 고정 `display`라면 상관 없겠지만 나중에 데스크탑 버전 또한 만들어야 하기 때문에 올바른 방법은 아니다. 또한 사용자가 글자의 크기를 변경 했을 때 글자가 아래로 무너지는 형태가 되는 것도 고려해야 한다. 
  - 🎯 **결정한 최선의 방법!** `<br />`을 사용하고 `role="text"`를 사용한다.   
  이 방법을 사용하면 [`role="text"`](http://ssamo.info/2019/11/27/roletext/)가 한 문장임을 인식하고 끊어 읽지 않고 자연스럽게 읽어 준다.

    <img src="./assets/20201128_TIL_attached_file1.jpg" width="300">

#### ourStory__description

- 놓친 부분 
  - 디자인 시안에서 `text-shadow` 잊지 말고 확인하기 매몰차게 무시하고 있었음...🥺
- 고민하기   
`ourStory__headline`과 마찬가지로 줄바뀜이 되어있다. 하지만 좀 더 고려해야 할 점은 데스크탑 버전에서 한 줄로 바뀐다. 그래서 위의 단락과 마찬가지로 `<br />`를 사용한다면 유지보수 관점에서 볼 때 옳은 방법은 아니다. 
  - `width` 값을 사용한다면 `font-size`를 `2rem`으로 조금 키우기만해도 글자가 아래로 무너진다. 이때 글자 크기를 키울 때 `transform: scalc()`을 사용해주면 아래로 무너지지 않고 글자의 크기만 커지고 작아진다. 그래서 미디어쿼리를 이용해서 데스크탑 버전에서 글자의 크기를 키우는 방향으로 하자. 이 방법도 문제가 하나 있다면 위의 단락과의 마진 간격에 영향을 준다는 것! 그래도 글자가 아래로 무너지는 것보다는 나은 방법이니 `width` 값을 주고 `transform`을 사용하는 것으로 선택!

```css
.ourStory__description {
  width: 20rem;
  transform: scalc(1.5)
}
```

```css
.ourStory__description {
  text-shadow: 0px 2px 6px rgba(0, 0, 0, 0.55);
}
```

#### Background Image

* 고민하기
  - **배경이미지를 어떻게 헤더영역에도 보이게 할까?**   
  많이 고민 했던 부분이다. 배경이미지가 `<main>`의 `ourStory`뿐만아니라 `<head>`까지 포함해서 배경으로 적용되있다는 것이다. 처음엔 컨테이너로 묶을 생각을 했지만 `ourStory`는 `<main>`의 자식요소 이기때문에 말도 안되는 소리였다. 
    - 해결!  
    헤더에 `p:f`를 적용하고 컨텐츠를 부유하게 만들어서 `ourStory`에 적용한 배경이미지가 헤더의 공간에도 보이도록 만드는 방법이 있다. 와우~!😝

  - **배경이미지를 반투명하게 하는 방법은?**      
  배경이미지가 반투명하게 음영처리가 되어있다. 이것을 딤(`dim`)/딤드(`dimmed`)라고 한다. 왜냐하면 딤처리가 되어있지 않은 일반 배경이미지에 흰색 글씨는 한 눈에 알아보기 쉽지 않기 때문이다. 
    - 디자인 시안에 보면 `linear-gradient`속성을 이미지 커버에 적용한 것을 확인 할 수 있다. 해당 코드를 `inspect`에서 확인해서 가져오도록 한다. (여기서 중요한 것은 해당 디자인에 적용한 효과를 어떻게 찾아내고 어디서 코드를 가져오는지 과정을 기억해야 한다.)
    
  - **`background` 속기형으로 입력하기** 
    1. `background`와 `background-size` 따로 입력하기
    1. `background`에 모두 입력하기    
    커버와 이미지를 동시에 적용했는데 `background-size`도 같이 한 줄에 입력할 수 있을까? **가능!**
    1. `b`의 코드를 좀 더 간소화 해보자   
    `linear-gradient`는 효과이기 때문에 `no-repeat`없어도 된다. 배경이미지는 뒤의 사이즈와 딱 알맞기 때문에 `no-repeat`이 없어도 이미지의 변화가 없다. 그리고 둘다 `X`/`Y`축 전부 `center`이기 때문에 `center` 한 번만 작성한다. 
    ```css
    .ourStory {
      /*  a  */
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.9) 5.68%, rgba(0, 0, 0, 0.3) 42.95%, rgba(0, 0, 0, 0.8) 79.3%), url("../../assets/Cover.jpg") no-repeat center center;
      background-size: 
      cover, /* linear-gradient, 커버효과이기 떄문에 auto, container 모두 가능 */  
      cover; /* 배경 이미지 */

      /*  b  */
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.9) 5.68%, rgba(0, 0, 0, 0.3) 42.95%, rgba(0, 0, 0, 0.8) 79.3%) no-repeat center center / auto, url("../../assets/Cover.jpg") no-repeat center / center;
      
      /*  c  */
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.9) 5.68%, rgba(0, 0, 0, 0.3) 42.95%, rgba(0, 0, 0, 0.8) 79.3%) center / auto,     url("../../assets/Cover.jpg") center / cover
    } 
    ```
* `<background-size>` 값은 `<background-position>` 바로 뒤에만 위치할 수 있으며 '/'로 구분한다. 
* `background`에 배경이미지와 커버, 이 두 가지를 같이 겹쳐서 넣은 것이다.  
* `background` 속기형 : 이미지, 반복, 위치, 사이즈